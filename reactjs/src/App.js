import React, { useEffect } from 'react';
import { connect } from 'react-redux'
import { BrowserRouter as BR, Route, Switch } from 'react-router-dom'; 
import Container from 'react-bootstrap/Container'
import { ToastContainer, toast } from 'react-toastify';
import LoadingOverlay from 'react-loading-overlay';
import io from 'socket.io-client';
import { CacheSwitch, CacheRoute } from "react-router-cache-route";

import Breadcrumbs from './pages/Breadcrumbs'
import HeaderBar from './pages/HeaderBar';
import Footer from './pages/Footer';
import routes from "./routes";
import ScrollToTopBtn from "./components/ScrollToTopBtn";

import { isEmpty, uniqueId } from "./utils"

const App = (props) => {
  const [timeInterval, setTimeInterval] = React.useState(undefined);
  
  useEffect(() => {
    socketid()

    if(!isEmpty(timeInterval)){
      clearInterval(timeInterval)
    }
    setTimeInterval(setInterval(syc, 30000, props))
  }, [props.user]);

  const syc =(props)=>{
    if(!isEmpty(props.user)){
      console.log("interval syc :", Date().toLocaleString(), uniqueId())
    }
  } 

  const socketid = () =>{
    const socket = io("/", {}, { transports: ["websocket"] });
    if (socket.connected === false && socket.connecting === false) {
      // use a connect() or reconnect() here if you want
      socket.connect()
      console.log('reconnected!');
    }
    socket.on('connect', () => {
      console.log('Socket io, connect!');
    })
    socket.on("message", data => {
      // setResponse(data);

      console.log(data)
    });

    socket.on('disconnect', ()=>{
      console.log('Socket io, disconnect!');

      // props.updateSocketIOStatus({status: false});
    });
  }

  return( <BR>
            <LoadingOverlay
              active={props.is_loading_overlay}
              spinner
              text='Wait...'>
              <div className="App">
                  <HeaderBar {...props} />
                  <Container>
                  <ToastContainer />
                  <CacheSwitch>
                    {routes.map(({ path, name, Component }, key) => (
                      <CacheRoute
                        exact
                        path={path}
                        key={key}
                        render={props => {
                          const crumbs = routes
                            // Get all routes that contain the current one.
                            .filter(({ path }) => props.match.path.includes(path))
                            // Swap out any dynamic routes with their param values.
                            // E.g. "/pizza/:pizzaId" will become "/pizza/1"
                            .map(({ path, ...rest }) => ({
                              path: Object.keys(props.match.params).length
                                ? Object.keys(props.match.params).reduce(
                                  (path, param) => path.replace(
                                    `:${param}`, props.match.params[param]
                                  ), path
                                  )
                                : path,
                              ...rest
                            }));

                          // if(this.props.logged_in){
                          //   connect_socketIO(this.props)
                          // }

                          // console.log();
                          console.log(`Generated crumbs for ${props.match.path}`);
                          crumbs.map(({ name, path }) => console.log({ name, path }));
                          return (
                            <div className="p-8">
                              <Breadcrumbs crumbs={crumbs} />
                              <Component {...props} />

                              <ScrollToTopBtn />
                              
                            </div>
                          );
                        }}
                      />
                    ))}
                  </CacheSwitch>
                  </Container>
                <Footer />  
              </div>
            </LoadingOverlay>
          </BR>)
}

const mapStateToProps = (state, ownProps) => {
	return {
    user: state.user.data,
    is_loading_overlay: state.user.is_loading_overlay,
  };
}

const mapDispatchToProps = (dispatch) => {
	return { }
}

export default connect(mapStateToProps, null)(App)
